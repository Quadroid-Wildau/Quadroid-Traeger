package de.th_wildau.quadroid.encoder;

import java.awt.image.BufferedImage;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.util.zip.CRC32;

import javax.imageio.ImageIO;
import org.slf4j.Logger;
import de.th_wildau.quadroid.QuadroidMain;
import de.th_wildau.quadroid.enums.Marker;
import de.th_wildau.quadroid.models.Attitude;
import de.th_wildau.quadroid.models.Course;
import de.th_wildau.quadroid.models.GeoData;
import de.th_wildau.quadroid.models.Landmark;
import de.th_wildau.quadroid.models.MetaData;
import de.th_wildau.quadroid.models.QuadroidAirplane;
import de.th_wildau.quadroid.models.Waypoint;


/**
 * This class encoded objects to byte data before transmission 
 * 
 * 
 * @author Thomas Rohde, trohde@th-wildau.de
 * @version 1.0 30.11.2013 (JDK 7) 
 * 
 * */

public class TxDataEncoder 
{
	/**instance of {@link org.slf4j.Logger} for logging*/
	private static Logger logger = QuadroidMain.logger;
	
	/**
	 * this function convert an {@link java.awt.image.BufferedImage} object to
	 * bytes
	 * 
	 * @param bufferedimage - hand over an reference of {@link java.awt.image.BufferedImage}
	 * 
	 * @param type - hand over an type of file for example: "jpg", "png", "bmp" or other...
	 * 
	 * @return return an byte-array contains data from given BufferedImage,
	 * return <b>null</b> if parameters are <tt>null</tt> 
	 * */
	public byte[] imageToByteArray(BufferedImage bufferedimage, String type)
	{	//prove parameter
		if(bufferedimage == null || type == null)
			return null;
		
		ByteArrayOutputStream bos = new ByteArrayOutputStream();
		try 
		{	//write image date into ByteArrayOutputStream
			ImageIO.write(bufferedimage, type, bos);
			logger.debug("Write data into ByteStream");
		} catch (IOException e) 
		{
			logger.error("ImageIO.write(bufferedimage, type, bos) Exception: ", e);
		}
		try 
		{
			bos.flush();//clean pipe
		} catch (IOException e) 
		{
			logger.error("bos.flush() Exception: ", e);
		}
		finally
		{
			try 
			{
				bos.close();//close pipe
			} catch (IOException e) 
			{
				logger.error("bos.close() Exception: ", e);
			}
		}	
		
		return bos.toByteArray();
	}
	
	/**
	 * this function convert data of type {@link Attitude} to bytes
	 * 
	 * @param attitude - hand over an reference of type {@link Attitude}
	 * 
	 * @return an array of bytes when operation was successfully, return <b>null</b>
	 * if input parameter are <tt>null</tt>
	 * 
	 * */
	public byte[] attitudeToBytes(Attitude attitude)
	{	
		if(attitude != null)
		{
			byte[] data = null;
			StringBuffer buffer = new StringBuffer();
			
			try
			{
				buffer.append(Attitude.YAWMARKER);
				buffer.append(String.valueOf(attitude.getYaw()));
				
				buffer.append(Attitude.ROLLMARKER);
				buffer.append(String.valueOf(attitude.getRoll()));
				
				buffer.append(Attitude.PITCHMARKER);
				buffer.append(String.valueOf(attitude.getPitch()));
				
			}catch(Exception e)
			{
				logger.error("Fail-attitudeToBytes: ", e);
				return null;
			}
			
			logger.debug("convert attitudeToBytes");
			return data;
		}
		
		return null;
	}
	
	/**
	 * this function convert data of type {@link Course} to bytes
	 * 
	 * @param course - hand over an reference of type {@link Course}
	 * 
	 * @return an array of bytes when operation was successfully, return <b>null</b>
	 * if input parameter are <tt>null</tt>
	 * 
	 * */
	public byte[] courseToBytes(Course course)
	{
		return null;
	}
	
	/**
	 * this function convert data of type {@link GeoData} to bytes
	 * 
	 * @param geodata - hand over an reference of type {@link GeoData}
	 * 
	 * @return an array of bytes when operation was successfully, return <b>null</b>
	 * if input parameter are <tt>null</tt>
	 * 
	 * */
	public byte[] geodataToBytes(GeoData geodata)
	{
		return null;
	}
	
	/**
	 * this function convert data of type {@link Landmark} to bytes
	 * 
	 * @param landmark - hand over an reference of type {@link Landmark}
	 * 
	 * @return an array of bytes when operation was successfully, return <b>null</b>
	 * if input parameter are <tt>null</tt>
	 * 
	 * */
	public byte[] landmarkToBytes(Landmark landmark)
	{
		return null;
	}
	
	
	/**
	 * this function convert data of type {@link MetaData} to bytes
	 * 
	 * @param metadata - hand over an reference of type {@link MetaData}
	 * 
	 * @return an array of bytes when operation was successfully, return <b>null</b>
	 * if input parameter are <tt>null</tt>
	 * 
	 * */
	public byte[] metadataToBytes(MetaData metadata)
	{
		return null;
	}
	
	/**
	 * this function convert data of type {@link QuadroidAirplane} to bytes
	 * 
	 * @param airplane - hand over an reference of type {@link QuadroidAirplane}
	 * 
	 * @return an array of bytes when operation was successfully, return <b>null</b>
	 * if input parameter are <tt>null</tt>
	 * 
	 * */
	public byte[] quadroidairplaneToBytes(QuadroidAirplane airplane)
	{
		return null;
	}
	
	/**
	 * this function convert data of type {@link Waypoint} to bytes
	 * 
	 * @param point - hand over an reference of type {@link Waypoint}
	 * 
	 * @return an array of bytes when operation was successfully, return <b>null</b>
	 * if input parameter are <tt>null</tt>
	 * 
	 * */
	public byte[] waypointToBytes(Waypoint point)
	{
		return null;
	}
	
	/**
	 * this function appends data - enclosed with marker-from second byte array to first array
	 * 
	 * @param availabledata - hand over available date at byte-array if no data available hand over <tt>null</tt>
	 * 
	 * @param startmarker - hand over an start marker see {@link de.th_wildau.quadroid.enums.Marker} 
	 * 
	 * @param appenddata - hand over data for append 
	 * 
	 * @param endmarker - hand over an end marker see {@link de.th_wildau.quadroid.enums.Marker} 
	 * 
	 * @return returns an byte array with data from first an second array, or <tt>null</tt> 
	 * if first or second array or marker are <tt>null</tt>
	 *  
	 * */
	public byte[] appendData(byte[] availabledata, String startmarker,
			byte[] appenddata, String endmarker) 
	{	//interrupt if data not valid
		if(availabledata == null || 
			 startmarker == null || 
			  appenddata == null || 
			  endmarker == null)
			return null;
		
		//length for allocate
		int length = (availabledata.length + startmarker.length() + 
				appenddata.length + endmarker.length());
		//create buffer with specific length
		ByteBuffer buffer = ByteBuffer.allocate(length);
		//set avaiable data
		buffer.put(availabledata);
		//set start marker for embedded data
		buffer.put(startmarker.getBytes());
		//append data
		buffer.put(appenddata);
		//set end marker
		buffer.put(endmarker.getBytes());
				
		return buffer.array();
	}
	
	/**
	 * this function append the CRC32 Checksum at last bytes into the array
	 * 
	 * @param data - hand over data for calculate crc checksum 
	 * 
	 * @return an array of bytes with appended CRC32 Checksum,
	 * if data <tt>null</tt> return null
	 *   
	 * */
	public byte[] appendCRC32(byte[] data) 
	{
		if(data == null)
			return null;
			
		CRC32 crc = new CRC32();
		//crc calculation
		crc.update(data);
		
		String crcvalue = String.valueOf(crc.getValue());
		String startmarker = Marker.CRCSTART.getMarker();
		String endmarker = Marker.CRCEND.getMarker();
		//length for allocation
		int length = (data.length + crcvalue.length() + 
				startmarker.length() + endmarker.length());
		//init buffer
		ByteBuffer buffer = ByteBuffer.allocate(length);
		//set data
		buffer.put(data);
		//set start marker
		buffer.put(startmarker.getBytes());
		//set crc value
		buffer.put(crcvalue.getBytes());
		//set end marker
		buffer.put(endmarker.getBytes());
		return buffer.array();
	}
}
